.\\" auto-generated by docbook2man-spec $Revision: 1.1.1.1 $
.TH "TRUNCATE" "7" "2009-06-27" "SQL - Language Statements" "SQL Commands"
.SH NAME
TRUNCATE \- empty a table or set of tables

.SH SYNOPSIS
.sp
.nf
TRUNCATE [ TABLE ] [ ONLY ] \fIname\fR [, ... ]
    [ RESTART IDENTITY | CONTINUE IDENTITY ] [ CASCADE | RESTRICT ]
.sp
.fi
.SH "DESCRIPTION"
.PP
\fBTRUNCATE\fR quickly removes all rows from a set of
tables. It has the same effect as an unqualified
\fBDELETE\fR on each table, but since it does not actually
scan the tables it is faster. Furthermore, it reclaims disk space
immediately, rather than requiring a subsequent \fBVACUUM\fR
operation. This is most useful on large tables.
.SH "PARAMETERS"
.TP
\fB\fIname\fB\fR
The name (optionally schema-qualified) of a table to be
truncated. If ONLY is specified, only that table is
truncated. If ONLY is not specified, the table and
all its descendant tables (if any) are truncated.
.TP
\fBRESTART IDENTITY\fR
Automatically restart sequences owned by columns of
the truncated table(s).
.TP
\fBCONTINUE IDENTITY\fR
Do not change the values of sequences. This is the default.
.TP
\fBCASCADE\fR
Automatically truncate all tables that have foreign-key references
to any of the named tables, or to any tables added to the group
due to CASCADE.
.TP
\fBRESTRICT\fR
Refuse to truncate if any of the tables have foreign-key references
from tables that are not listed in the command. This is the default.
.SH "NOTES"
.PP
You must have the TRUNCATE privilege on a table
to truncate it.
.PP
\fBTRUNCATE\fR acquires an ACCESS EXCLUSIVE lock on each
table it operates on, which blocks all other concurrent operations
on the table. If concurrent access to a table is required, then
the \fBDELETE\fR command should be used instead.
.PP
\fBTRUNCATE\fR cannot be used on a table that has foreign-key
references from other tables, unless all such tables are also truncated
in the same command. Checking validity in such cases would require table
scans, and the whole point is not to do one. The CASCADE
option can be used to automatically include all dependent tables \(em
but be very careful when using this option, or else you might lose data you
did not intend to!
.PP
\fBTRUNCATE\fR will not fire any ON DELETE
triggers that might exist for the tables. But it will fire
ON TRUNCATE triggers.
If ON TRUNCATE triggers are defined for any of
the tables, then all BEFORE TRUNCATE triggers are
fired before any truncation happens, and all AFTER
TRUNCATE triggers are fired after the last truncation is
performed. The triggers will fire in the order that the tables are
to be processed (first those listed in the command, and then any
that were added due to cascading).
.sp
.RS
.B "Warning:"
\fBTRUNCATE\fR is not MVCC-safe (see in the documentation
for general information about MVCC). After truncation, the table
will appear empty to all concurrent transactions, even if they
are using a snapshot taken before the truncation occurred. This
will only be an issue for a transaction that did not access the
truncated table before the truncation happened \(em any
transaction that has done so would hold at least an
ACCESS SHARE lock, which would block
\fBTRUNCATE\fR until that transaction completes. So
truncation will not cause any apparent inconsistency in the table
contents for successive queries on the same table, but it could
cause visible inconsistency between the contents of the truncated
table and other tables in the database.
.RE
.sp
.PP
\fBTRUNCATE\fR is transaction-safe with respect to the data
in the tables: the truncation will be safely rolled back if the surrounding
transaction does not commit.
.sp
.RS
.B "Warning:"
Any \fBALTER SEQUENCE RESTART\fR operations performed as a
consequence of using the RESTART IDENTITY option are
nontransactional and will not be rolled back on failure. To minimize
the risk, these operations are performed only after all the rest of
\fBTRUNCATE\fR's work is done. However, there is still a risk
if \fBTRUNCATE\fR is performed inside a transaction block that is
aborted afterwards. For example, consider
.sp
.nf
BEGIN;
TRUNCATE TABLE foo RESTART IDENTITY;
COPY foo FROM ...;
COMMIT;
.sp
.fi
If the \fBCOPY\fR fails partway through, the table data
rolls back correctly, but the sequences will be left with values
that are probably smaller than they had before, possibly leading
to duplicate-key failures or other problems in later transactions.
If this is likely to be a problem, it's best to avoid using
RESTART IDENTITY, and accept that the new contents of
the table will have higher serial numbers than the old.
.RE
.sp
.SH "EXAMPLES"
.PP
Truncate the tables bigtable and
fattable:
.sp
.nf
TRUNCATE bigtable, fattable;
.sp
.fi
.PP
The same, and also reset any associated sequence generators:
.sp
.nf
TRUNCATE bigtable, fattable RESTART IDENTITY;
.sp
.fi
.PP
Truncate the table othertable, and cascade to any tables
that reference othertable via foreign-key
constraints:
.sp
.nf
TRUNCATE othertable CASCADE;
.sp
.fi
.SH "COMPATIBILITY"
.PP
The SQL:2008 standard includes a \fBTRUNCATE\fR command with the syntax
TRUNCATE TABLE \fItablename\fR.
The clauses CONTINUE IDENTITY/RESTART IDENTITY
also appear in that standard but have slightly different but related meanings.
Some of the concurrency behavior of this command is left implementation-defined
by the standard, so the above notes should be considered and compared with
other implementations if necessary.
